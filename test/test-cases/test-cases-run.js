const buster = require('buster')
const request = require('supertest')
const fs = require('fs')
const Table = require('cli-table')
const app = require('../../lib')
const os = require('os')

const mongoose = require('mongoose')
const dbConfig = require('../../../db-config')

let allTestCases = {}
// allTestCases get loaded
allTestCases = getAllTestCases()
var hitCounter = 0
var length = 0
var table = new Table({
  head: ['TestCase file', 'größter Score', 'Index', 'Teilscores', 'größter Teilscore', 'kleinster Teilscore'],
  chars: {'mid': '', 'left-mid': '', 'mid-mid': '', 'right-mid': ''},
  style: {head: ['green'], border: ['grey']}
})

/**
 * Setting Up function of the scoretest:
 * Sets up a connection to the test-database, authenticates this program
 * and requests a token for later use in the test-cases.
 * @return token in done-function
**/
function settingUp (done) {
  process.env.ARROW_ADMIN_PASSWORD = 'hello123'

  const db = dbConfig.test
  mongoose.connect(db)

  request(app)
    .post('/api/auth')
    .send({ name: 'admin', password: 'hello123' })
    .expect(200)
    .end(function (err, res) {
      buster.refute(err)
      done(res.body.token)
    })
}

/**
 * Runs through all the testcases after the database has been set up and a
 * valid token has been gathered.
 * @param token: A valid token
**/
function runTestCases (token, done) {
  var dataToWrite = '' + 'TestCase file;größter Score;Index;Teilscores;größter Teilscore;kleinster Teilscore\n'
  for (let key in allTestCases) {
    var testCases = allTestCases[key]
    length += testCases.length
    for (let testCase of testCases) {
      testCase.token = token
      request(app)
        .post('/api/score')
        .send(testCase)
        .end(function (err, res) {
          buster.refute(err)

          let biggestAIndex = 0
          let biggestAScore = 0
          for (let j in res.body.result) {
            if (res.body.result[j].total > biggestAScore) {
              biggestAIndex = j
              biggestAScore = res.body.result[j].total
            }
          }
          // number of totally used partial Scores.
          let numberOfPartialScores = 0
          // biggest partial Score together with the plugin used.
          // Set Score to -1 which is out of range for numbers generated by Plugins.
          let biggestPartialScore = {
            score: -1,
            key: ''
          }
          // smallest partial Score together with the plugin used.
          // Set Score to 2 which is out of range for numbers generated by Plugins.
          let smallestPartialScore = {
            score: 2,
            key: ''
          }

          Object.keys(res.body.result[biggestAIndex]).forEach(function (key, index) {
            if (key !== 'total') {
              let partialScore = res.body.result[biggestAIndex][key]
              // partialScore is a number
              if (typeof partialScore === 'number') {
                // increase number of used Plugins.
                numberOfPartialScores++
                // if higher partial Score found, update biggest partial Score and its plugin.
                if (partialScore > biggestPartialScore.score) {
                  biggestPartialScore.score = partialScore
                  biggestPartialScore.key = key
                }
                // if smaller partial Score found, update smallest partial Score and its plugin.
                if (partialScore < smallestPartialScore.score) {
                  smallestPartialScore.score = partialScore
                  smallestPartialScore.key = key
                }
              }
            }
          })
          if (biggestAIndex === '0') {
            hitCounter++
          }
          table.push([key, biggestAScore, biggestAIndex, numberOfPartialScores,
            (biggestPartialScore.score + '  (' + biggestPartialScore.key + ')'),
            (smallestPartialScore.score + '  (' + smallestPartialScore.key + ')')])

          dataToWrite = '' + dataToWrite + key + ';' + biggestAScore + ';' + biggestAIndex + ';' + numberOfPartialScores +
            (biggestPartialScore.score + '  (' + biggestPartialScore.key + ')') + ';' +
            (smallestPartialScore.score + '  (' + smallestPartialScore.key + ')') + os.EOL
        })
    }
  }

  // Timeout needed because supertest runs tests asynchronously and nesting callbacks for 60 tests wouldn't be feasible.
  // No better workaround found than waiting 3 seconds until hopefully all asynchronous tests have run through.
  setTimeout(function () {
    const hitRate = hitCounter / length
    console.log(table.toString())
    console.log('Länge: ' + length)
    console.log('Hits: ' + hitCounter)
    console.log((hitRate * 100) + '% wurden korrekt bewertet.')
    console.log('______________________________________')

    // Write outputs to .csv
    fs.writeFile('scoretest.csv', dataToWrite, 'utf8', function (err) {
      if (err) {
        console.log('Some error occured - file either not saved or corrupted file saved.')
      } else {
        console.log('It\'s saved!')
      }
      done()
    })
  }, 3000)
}
/**
*dynamic loads of all testcases in the folder ('./test/test-cases') with the format of <NAME>-test-cases.js
*/
function getAllTestCases () {
  let testCasesSet = {}
  let files = fs.readdirSync('./test/test-cases')
  for (let file of files) {
    if (file.substring(file.length - 13, file.length) === 'test-cases.js') {
      testCasesSet[file] = require('./' + file.substring(0, file.length - 3)).testCases
    }
  }
  return testCasesSet
}

/**
  * First calls the setup-method and when the setup is completely done,
  * the actual test-cases method gets called.
**/
settingUp((token) => {
  runTestCases(token, () => {
    console.log('all test-cases done.')
  })
})
